<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">clase-date</a> &gt; <a href="index.source.html" class="el_package">es.ies.puerto</a> &gt; <span class="el_source">DateUtils.java</span></div><h1>DateUtils.java</h1><pre class="source lang-java linenums">package es.ies.puerto;

import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Period;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.TemporalAdjusters;
import java.util.Date;

/**
 * @author eduglezexp
 * @version 1.0.0
 */

<span class="nc" id="L22">public class DateUtils {</span>

    /**
     * Funcion para crear una nueva fecha
     * @return nueva fecha
     */
    public static Date createDate() {
<span class="fc" id="L29">        return new Date();</span>
    }

    /**
     * Funcion para Compara dos fechas y determina si la primera es 
     * anterior a la segunda
     * @param date1 primera fecha a comparar
     * @param date2 segunda fecha a comparar
     * @return true/false
     */
    public static boolean compareDates(Date date1, Date date2) {
<span class="pc bpc" id="L40" title="2 of 4 branches missed.">        if (date1 == null || date2 == null) {</span>
<span class="nc" id="L41">            return false;</span>
        }
<span class="fc" id="L43">        return date1.before(date2);</span>
    }
    
    /**
     * Funcion para sumar un número específico de días a un objeto Date
     * @param date a la que se le va a sumar los dias
     * @param days que se le van a sumar a la fecha
     * @return fecha actualizada con los dias sumados
     */
    public static Date addDaysToDate(Date date, int days) {
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L54">            return date;</span>
        }
<span class="fc" id="L56">        long fechaMilisegundos = date.getTime()+days*24L*60*60*1000;</span>
<span class="fc" id="L57">        return new Date(fechaMilisegundos);</span>
    }

    /**
     * Funcion para convertir un objeto Date a una cadena de texto 
     * con formato yyyy-MM-dd
     * @param date
     * @return fecha formateada
     */
    public static String formatDate(Date date) {
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L68">            return null;</span>
        }
<span class="fc" id="L70">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span>
<span class="fc" id="L71">        return simpleDateFormat.format(date);</span>
    }

    /**
     * Funcion que calcula la diferencia en días entre dos fechas
     * @param date1 para calcular la diferencia
     * @param date2 para calcular la diferencia
     * @return long con la diferencia en dias
     */
    public static long calculateDateDifference(Date date1, Date date2) {
<span class="pc bpc" id="L81" title="2 of 4 branches missed.">        if (date1 == null || date2 == null) {</span>
<span class="nc" id="L82">            return 0;</span>
        }
<span class="fc" id="L84">        long time1 = date1.getTime();</span>
<span class="fc" id="L85">        long time2 = date2.getTime();</span>
<span class="fc" id="L86">        long diferenciaEnMilisegundos = Math.abs(time1 - time2);</span>
<span class="fc" id="L87">        return diferenciaEnMilisegundos / (24 * 60 * 60 * 1000);</span>
    }

    /**
     * Funcion que obtiene la fecha actual utilizando LocalDate
     * @return fecha actual
     */
    public static LocalDate getCurrentLocalDate() {
<span class="fc" id="L95">        return LocalDate.now();</span>
    }

    /**
     * Funcion que crea un objeto LocalDate con un año, mes y día específicos
     * @param year de la fecha
     * @param month de la fecha
     * @param day de la fecha
     * @return fecha construida
     */
    public static LocalDate createSpecificLocalDate(int year, int month, int day) {
<span class="fc" id="L106">        return LocalDate.of(year, month, day);</span>
    }

    /**
     * Funcion para sumar un numero especifico de dias a un objeto LocalDate
     * @param date a la que se le suman los dias
     * @param days que se le van a sumar a la fecha
     * @return nueva fecha ajustado con los dias agregados
     */
    public static LocalDate addDays(LocalDate date, int days) {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L117">            return null;</span>
        }
<span class="fc" id="L119">        return date.plusDays(days);</span>
    }

    /**
     * Funcion que determina si una fecha LocalDate es anterior a otra
     * @param date1 fecha a comparar
     * @param date2 fecha de referencia
     * @return true/false
     */
    public static boolean isBefore(LocalDate date1, LocalDate date2) {
<span class="pc bpc" id="L129" title="2 of 4 branches missed.">        if (date1 == null || date2 == null) {</span>
<span class="nc" id="L130">            return false;</span>
        }
<span class="fc" id="L132">        return date1.isBefore(date2);</span>
    }

    /**
     * Funcion que calcula la diferencia en anios, meses y días entre dos fechas LocalDate
     * @param start fecha inicail
     * @param end fecha final
     * @return la diferencia entre ambas fechas en anios, meses y día
     */
    public static Period calculatePeriodBetween(LocalDate start, LocalDate end) {
<span class="pc bpc" id="L142" title="2 of 4 branches missed.">        if (start == null || end == null) {</span>
<span class="nc" id="L143">            return null;</span>
        }
<span class="fc" id="L145">        return Period.between(start, end);</span>
    }

    /**
     * Funcion que obtiene la hora actual utilizando LocalTime
     * @return la hora actual
     */
    public static LocalTime getCurrentLocalTime() {
<span class="fc" id="L153">        return LocalTime.now();    </span>
    }

    /**
     * Funcion que suma un numero especifico de minutos a un objeto LocalTime
     * @param time hora base 
     * @param minutes minutos a agregar (puede ser negativo)
     * @return hora con los minutos sumados
     */
    public static LocalTime addMinutes(LocalTime time, int minutes) {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (time == null) {</span>
<span class="nc" id="L164">            return null;</span>
        }
<span class="fc" id="L166">        return time.plusMinutes(minutes);</span>
    }

    /**
     * Funcion que determina si una hora LocalTime ocurre antes que otra
     * @param time1 hora a comparar
     * @param time2 hora de referencia
     * @return true/false
     */
    public static boolean isTimeBefore(LocalTime time1, LocalTime time2) {
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">        if (time1 == null || time2 == null) {</span>
<span class="nc" id="L177">            return false;</span>
        }
<span class="fc" id="L179">        return time1.isBefore(time2);</span>
    }

    /**
     * Funcion que obtiene la fecha y hora actual utilizando LocalDateTime
     * @return fecha y hora actual
     */
    public static LocalDateTime getCurrentLocalDateTime() {
<span class="fc" id="L187">        return LocalDateTime.now();</span>
    }

    /**
     * Funcion que suma un numero especifico de horas a un objeto LocalDateTime 
     * @param dateTime fecha y hora base
     * @param hours numero de horas a agregar (puede ser negativo)
     * @return hora actualizada
     */
    public static LocalDateTime addHours(LocalDateTime dateTime, int hours) {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (dateTime == null) {</span>
<span class="nc" id="L198">            return null;</span>
        }
<span class="fc" id="L200">        return dateTime.plusHours(hours);</span>
    }

    /**
     * Funcion que resta un numero especifico de meses a un objeto LocalDateTime
     * @param dateTime fecha y hora base
     * @param months numero de meses a restar
     * @return mes actualizado
     */
    public static LocalDateTime subtractMonths(LocalDateTime dateTime, int months) {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (dateTime == null) {</span>
<span class="nc" id="L211">            return null;</span>
        }
<span class="fc" id="L213">        return dateTime.minusMonths(months);</span>
    }

    /**
     * Funcion que obtinene la fecha y hora actuales en una zona horaria especifica
     * @param zoneId Identificador de zona horaria (por ejemplo, &quot;Europe/Madrid&quot;)
     * @return fecha y hora actuales en un zona especifica
     */
    public static ZonedDateTime getZonedDateTime(String zoneId) {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (zoneId == null) {</span>
<span class="nc" id="L223">            return null;</span>
        }
<span class="fc" id="L225">        return ZonedDateTime.now(ZoneId.of(zoneId));</span>
    }
    
    /**
     * Funcion que convierte un objeto ZonedDateTime de una zona horaria a otra
     * @param dateTime fecha y hora en la zona horaria original
     * @param targetZoneId identificador de la zona horaria de destino
     * @return fecha y hora convertida a otra zona horaria
     */
    public static ZonedDateTime convertZone(ZonedDateTime dateTime, String targetZoneId) {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (dateTime == null) {</span>
<span class="nc" id="L236">            return null;</span>
        }
<span class="fc" id="L238">        return dateTime.withZoneSameInstant(ZoneId.of(targetZoneId));</span>
    }

    /**
     * Funcion que obtiene el primer dia del mes de una fecha LocalDate dada
     * @param date fecha base
     * @return el primer dia del mes
     */
    public static LocalDate getFirstDayOfMonth(LocalDate date) {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L248">            return null;</span>
        }
<span class="fc" id="L250">        return date.withDayOfMonth(1);</span>
    }
    
    /**
     * Funcion que obtiene el ultimo dia del mes de una fecha LocalDate dada
     * @param date fecha base
     * @return el ultimo dia del mes 
     */
    public static LocalDate getLastDayOfMonth(LocalDate date) {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L260">            return null;</span>
        }
<span class="fc" id="L262">        return date.withDayOfMonth(date.lengthOfMonth());</span>
    }

    /**
     * Funcion para verificar si el anio de una fecha LocalDate dada es bisiesto
     * @param date fecha base
     * @return true/false
     */
    public static boolean isLeapYear(LocalDate date) {
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L272">            return false;</span>
        }
<span class="fc" id="L274">        return date.isLeapYear();</span>
    }

    /**
     * Funcion que mide el tiempo de ejecución de una tarea representada como un objeto Runnable
     * @param task tarea cuya duracion se medira
     * @return duracion de la tarea en milisegundos (ms)
     */
    public static Duration measureExecutionTime(Runnable task) {
<span class="fc" id="L283">        long startTime = System.nanoTime();</span>
<span class="fc" id="L284">        task.run();</span>
<span class="fc" id="L285">        long endTime = System.nanoTime();</span>
<span class="fc" id="L286">        long durationInNanos = endTime - startTime;</span>
<span class="fc" id="L287">        return Duration.ofNanos(durationInNanos);</span>
    }

    /**
     * Funcion que convierte una cadena de texto en un objeto LocalDate utilizando un 
     * formato especifico
     * @param date fecha en formato texto
     * @param format formato esperado de la fecha (por ejemplo, &quot;yyyy-MM-dd&quot;)
     * @return fecha con el nuevo formato
     * @throws DateTimeParseException
     */
    public static LocalDate parseDate(String date, String format) throws DateTimeParseException {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L300">            return null;</span>
        }
<span class="pc bpc" id="L302" title="2 of 4 branches missed.">        if (format.isEmpty() || format == null) {</span>
<span class="nc" id="L303">            return null;</span>
        }
<span class="fc" id="L305">        DateTimeFormatter formato = DateTimeFormatter.ofPattern(format);</span>
<span class="fc" id="L306">        return LocalDate.parse(date, formato);</span>
    }

    public static void main(String[] args) {
<span class="nc" id="L310">        System.out.println(&quot;Vamos a probar los algoritmos&quot;);</span>
<span class="nc" id="L311">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>